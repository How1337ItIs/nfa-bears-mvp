'use client';\n\nimport { useEffect, useRef, useState, useCallback } from 'react';\nimport { AUTHENTIC_CONFIGS, DeviceCapabilities, detectDeviceCapabilities } from '@/lib/fluid/config';\nimport { setupThermalCurrents, setupGlobalMotion } from '@/lib/fluid/thermal';\nimport { useAudioReactive } from '@/lib/audio/useAudioReactive';\n\n// SINGLE ENGINE OF RECORD - webgl-fluid-enhanced only\n// Eliminates parallel CSS/WebGL systems per unified recommendation\n\ninterface PerformanceMetrics {\n  fps: number;\n  frameCount: number;\n  lastFpsCheck: number;\n  tier: 'high' | 'medium' | 'low';\n}\n\nexport default function LiquidLightBackground() {\n  const canvasRef = useRef<HTMLCanvasElement>(null);\n  const fluidRef = useRef<any>(null);\n  const performanceRef = useRef<PerformanceMetrics>({\n    fps: 60,\n    frameCount: 0,\n    lastFpsCheck: Date.now(),\n    tier: 'high'\n  });\n  \n  const [capabilities, setCapabilities] = useState<DeviceCapabilities | null>(null);\n  const [currentTier, setCurrentTier] = useState<'high' | 'medium' | 'low'>('high');\n  const [isLoaded, setIsLoaded] = useState(false);\n  const [hasError, setHasError] = useState(false);\n  \n  // Centralized audio reactivity (single analyzer)\n  const { audioData, physicsParams } = useAudioReactive();\n\n  // Device capability detection on mount\n  useEffect(() => {\n    const caps = detectDeviceCapabilities();\n    setCapabilities(caps);\n    setCurrentTier(caps.tier);\n  }, []);\n\n  // Auto-quality adjustment based on FPS monitoring\n  const monitorPerformance = useCallback(() => {\n    if (!capabilities) return;\n    \n    const now = Date.now();\n    performanceRef.current.frameCount++;\n    \n    // Check FPS every 60 frames (~1 second at 60fps)\n    if (performanceRef.current.frameCount % 60 === 0) {\n      const elapsed = now - performanceRef.current.lastFpsCheck;\n      const currentFps = Math.round(60000 / elapsed);\n      performanceRef.current.fps = currentFps;\n      \n      // Auto-quality step-down logic\n      if (currentFps < 25 && currentTier !== 'low') {\n        const newTier = currentTier === 'high' ? 'medium' : 'low';\n        console.warn(`Performance degradation: ${currentFps}fps, stepping down to ${newTier}`);\n        setCurrentTier(newTier);\n      } else if (currentFps > 50 && currentTier !== capabilities.tier) {\n        const newTier = currentTier === 'low' ? 'medium' : capabilities.tier;\n        console.log(`Performance improved: ${currentFps}fps, stepping up to ${newTier}`);\n        setCurrentTier(newTier);\n      }\n      \n      performanceRef.current.lastFpsCheck = now;\n    }\n  }, [capabilities, currentTier]);\n\n  // Main fluid engine initialization\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    if (!canvas || !capabilities?.webgl || hasError) return;\n\n    let cleanupFunctions: (() => void)[] = [];\n    \n    const initFluid = async () => {\n      try {\n        // Dynamic import to avoid SSR issues\n        const { default: webGLFluidEnhanced } = await import('webgl-fluid-enhanced');\n        \n        // Get authentic config for current tier\n        const config = AUTHENTIC_CONFIGS[currentTier];\n        \n        // Initialize fluid with authentic 60s parameters\n        const fluidInstance = webGLFluidEnhanced.simulation(canvas, {\n          ...config,\n          // Ensure proper canvas setup\n          TRANSPARENT: true,\n          INITIAL: true,\n          HOVER: true\n        });\n        \n        fluidRef.current = fluidInstance;\n        setIsLoaded(true);\n        \n        // Setup thermal convection (authentic physics)\n        const thermalCleanup = setupThermalCurrents(fluidInstance, canvas, physicsParams);\n        cleanupFunctions.push(thermalCleanup);\n        \n        // Setup subtle global motion to avoid digital stillness\n        const motionCleanup = setupGlobalMotion(fluidInstance, canvas);\n        cleanupFunctions.push(motionCleanup);\n        \n        // Start performance monitoring\n        let animationId: number;\n        const performanceLoop = () => {\n          monitorPerformance();\n          animationId = requestAnimationFrame(performanceLoop);\n        };\n        performanceLoop();\n        \n        cleanupFunctions.push(() => cancelAnimationFrame(animationId));\n        \n        console.log(`Liquid light initialized: tier ${currentTier}, config:`, config);\n        \n      } catch (error) {\n        console.error('Fluid initialization failed:', error);\n        setHasError(true);\n      }\n    };\n    \n    initFluid();\n    \n    // Cleanup function\n    return () => {\n      cleanupFunctions.forEach(cleanup => cleanup());\n      if (fluidRef.current?.dispose) {\n        fluidRef.current.dispose();\n      }\n    };\n  }, [capabilities, currentTier, hasError, monitorPerformance, physicsParams]);\n\n  // Canvas resize handling\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n\n    const resizeCanvas = () => {\n      canvas.width = window.innerWidth;\n      canvas.height = window.innerHeight;\n    };\n    \n    resizeCanvas();\n    window.addEventListener('resize', resizeCanvas);\n    return () => window.removeEventListener('resize', resizeCanvas);\n  }, []);\n\n  // Handle WebGL context lost\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n\n    const handleContextLost = (event: Event) => {\n      event.preventDefault();\n      console.warn('WebGL context lost, falling back to CSS');\n      setHasError(true);\n    };\n\n    canvas.addEventListener('webglcontextlost', handleContextLost);\n    return () => canvas.removeEventListener('webglcontextlost', handleContextLost);\n  }, []);\n\n  // Audio reactivity integration\n  useEffect(() => {\n    if (!fluidRef.current || !audioData || !isLoaded) return;\n    \n    // Apply audio-reactive physics parameters\n    const { splatForce, thermalRate } = physicsParams;\n    \n    // Beat-triggered splats\n    if (audioData.beatDetected && fluidRef.current.splat) {\n      const canvas = canvasRef.current;\n      if (canvas) {\n        const x = Math.random() * canvas.width;\n        const y = Math.random() * canvas.height;\n        const vx = (Math.random() - 0.5) * splatForce;\n        const vy = (Math.random() - 0.5) * splatForce;\n        const color = [1, 0.8, 0.2]; // Beat color\n        \n        fluidRef.current.splat(x, y, vx, vy, color);\n      }\n    }\n  }, [audioData, physicsParams, isLoaded]);\n\n  // Strict fallback chain: WebGL â†’ CSS fallback only\n  if (!capabilities?.webgl || hasError) {\n    return (\n      <div className=\"fixed inset-0 -z-10 w-full h-full pointer-events-none\">\n        <div className=\"w-full h-full bg-gradient-to-br from-purple-900/20 via-pink-900/20 to-blue-900/20 animate-pulse\" \n             style={{ animationDuration: '4s' }} />\n      </div>\n    );\n  }\n\n  return (\n    <>\n      {/* Development HUD */}\n      {process.env.NODE_ENV === 'development' && (\n        <div className=\"fixed top-4 right-4 z-50 text-white text-xs bg-black/70 p-3 rounded backdrop-blur\">\n          <div>FPS: {performanceRef.current.fps}</div>\n          <div>Tier: {currentTier} (max: {capabilities.tier})</div>\n          <div>Audio: Bass {audioData?.bass.toFixed(2)} | Mids {audioData?.mids.toFixed(2)} | Treble {audioData?.treble.toFixed(2)}</div>\n          <div>WebGL: {capabilities.webgl2 ? 'v2' : 'v1'} | Max Texture: {capabilities.maxTextureSize}</div>\n          <div>Memory: {capabilities.deviceMemory}GB | Mobile: {capabilities.mobile ? 'Yes' : 'No'}</div>\n        </div>\n      )}\n      \n      {/* Single full-viewport canvas - engine of record */}\n      <canvas\n        ref={canvasRef}\n        className=\"fixed inset-0 -z-10 w-full h-full pointer-events-none\"\n        style={{\n          mixBlendMode: 'screen',\n          opacity: 0.8,\n          background: 'transparent'\n        }}\n        role=\"img\"\n        aria-label=\"Authentic 1960s liquid light show background\"\n      />\n    </>\n  );\n}\n"