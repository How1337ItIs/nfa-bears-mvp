// THERMAL CONVECTION & GLOBAL MOTION SYSTEMS\n// Authentic 60s physics simulation for oil-on-water effects\n\nimport { THERMAL_CONFIG, MOTION_CONFIG } from './config';\nimport type { AudioReactiveParams } from '@/lib/audio/useAudioReactive';\n\n// THERMAL CURRENT SIMULATION\n// Simulates heat-driven convection currents rising from bottom\nexport function setupThermalCurrents(\n  fluidInstance: any,\n  canvas: HTMLCanvasElement,\n  physicsParams: AudioReactiveParams\n): () => void {\n  let thermalInterval: NodeJS.Timeout;\n  \n  const addThermalCurrent = () => {\n    if (!fluidInstance || !fluidInstance.splat || !canvas) return;\n    \n    // Random position in bottom zone (heat rises from below)\n    const x = Math.random() * canvas.width;\n    const y = canvas.height * (1 - Math.random() * THERMAL_CONFIG.BOTTOM_ZONE);\n    \n    // Upward force with audio reactivity\n    const baseForce = THERMAL_CONFIG.FORCE_MIN + Math.random() * THERMAL_CONFIG.FORCE_VARIATION;\n    const audioModifiedForce = baseForce * (1 + physicsParams.thermalRate * 0.2);\n    \n    // Thermal currents always move upward\n    const vx = (Math.random() - 0.5) * 3; // Small horizontal variation\n    const vy = -audioModifiedForce;        // Upward force (negative Y)\n    \n    // Warm thermal colors (orange-yellow spectrum)\n    const color = [\n      THERMAL_CONFIG.THERMAL_COLOR[0] * (0.8 + Math.random() * 0.4),\n      THERMAL_CONFIG.THERMAL_COLOR[1] * (0.6 + Math.random() * 0.4),\n      THERMAL_CONFIG.THERMAL_COLOR[2] * (0.1 + Math.random() * 0.3)\n    ];\n    \n    fluidInstance.splat(x, y, vx, vy, color);\n  };\n  \n  const scheduleThermalEvent = () => {\n    // Audio-reactive timing\n    const baseInterval = THERMAL_CONFIG.INTERVAL_MIN + Math.random() * THERMAL_CONFIG.INTERVAL_VARIATION;\n    const audioModifiedInterval = baseInterval / (1 + physicsParams.thermalRate * 0.3);\n    \n    thermalInterval = setTimeout(() => {\n      addThermalCurrent();\n      scheduleThermalEvent(); // Reschedule next event\n    }, audioModifiedInterval);\n  };\n  \n  // Start thermal convection\n  scheduleThermalEvent();\n  \n  // Cleanup function\n  return () => {\n    if (thermalInterval) {\n      clearTimeout(thermalInterval);\n    }\n  };\n}\n\n// GLOBAL MOTION SIMULATION\n// Adds subtle rotation and drift to prevent digital stillness\nexport function setupGlobalMotion(\n  fluidInstance: any,\n  canvas: HTMLCanvasElement\n): () => void {\n  let motionInterval: NodeJS.Timeout;\n  let rotationPhase = Math.random() * Math.PI * 2; // Start at random phase\n  \n  const addGlobalMotion = () => {\n    if (!fluidInstance || !fluidInstance.splat || !canvas) return;\n    \n    // Update rotation phase\n    rotationPhase += MOTION_CONFIG.ROTATION_SPEED;\n    if (rotationPhase > Math.PI * 2) {\n      rotationPhase -= Math.PI * 2;\n    }\n    \n    // Calculate position on circular path\n    const centerX = canvas.width / 2;\n    const centerY = canvas.height / 2;\n    const radius = Math.min(canvas.width, canvas.height) * MOTION_CONFIG.ROTATION_RADIUS;\n    \n    const x = centerX + Math.cos(rotationPhase) * radius;\n    const y = centerY + Math.sin(rotationPhase) * radius;\n    \n    // Tangential velocity for circular motion\n    const vx = -Math.sin(rotationPhase) * MOTION_CONFIG.ROTATION_FORCE;\n    const vy = Math.cos(rotationPhase) * MOTION_CONFIG.ROTATION_FORCE;\n    \n    // Subtle neutral colors for background motion\n    const intensity = 0.3 + Math.sin(rotationPhase * 0.5) * 0.2;\n    const color = [\n      MOTION_CONFIG.ROTATION_COLOR[0] * intensity,\n      MOTION_CONFIG.ROTATION_COLOR[1] * intensity,\n      MOTION_CONFIG.ROTATION_COLOR[2] * intensity\n    ];\n    \n    fluidInstance.splat(x, y, vx, vy, color);\n  };\n  \n  const scheduleMotionEvent = () => {\n    motionInterval = setTimeout(() => {\n      addGlobalMotion();\n      scheduleMotionEvent(); // Reschedule\n    }, MOTION_CONFIG.ROTATION_INTERVAL);\n  };\n  \n  // Start global motion\n  scheduleMotionEvent();\n  \n  // Cleanup function\n  return () => {\n    if (motionInterval) {\n      clearTimeout(motionInterval);\n    }\n  };\n}\n\n// SURFACE PERTURBATION\n// Adds random gentle disturbances for organic feel\nexport function addRandomPerturbation(\n  fluidInstance: any,\n  canvas: HTMLCanvasElement,\n  intensity: number = 0.5\n): void {\n  if (!fluidInstance || !fluidInstance.splat || !canvas) return;\n  \n  // Random position\n  const x = Math.random() * canvas.width;\n  const y = Math.random() * canvas.height;\n  \n  // Small random forces\n  const vx = (Math.random() - 0.5) * 4 * intensity;\n  const vy = (Math.random() - 0.5) * 4 * intensity;\n  \n  // Very subtle color\n  const color = [\n    Math.random() * 0.3,\n    Math.random() * 0.3,\n    Math.random() * 0.3\n  ];\n  \n  fluidInstance.splat(x, y, vx, vy, color);\n}\n\n// BEAT-TRIGGERED EFFECTS\n// Special effects for audio beat detection\nexport function addBeatEffect(\n  fluidInstance: any,\n  canvas: HTMLCanvasElement,\n  audioData: { bass: number; mids: number; treble: number; volume: number }\n): void {\n  if (!fluidInstance || !fluidInstance.splat || !canvas) return;\n  \n  // Beat effects are more dramatic and centered\n  const centerX = canvas.width / 2;\n  const centerY = canvas.height / 2;\n  \n  // Radial burst pattern\n  const numSplats = 3 + Math.floor(audioData.volume * 5);\n  const angleStep = (Math.PI * 2) / numSplats;\n  const radius = Math.min(canvas.width, canvas.height) * 0.1;\n  \n  for (let i = 0; i < numSplats; i++) {\n    const angle = i * angleStep + Math.random() * 0.5;\n    const x = centerX + Math.cos(angle) * radius * (0.5 + Math.random() * 0.5);\n    const y = centerY + Math.sin(angle) * radius * (0.5 + Math.random() * 0.5);\n    \n    // Outward radial velocity\n    const force = 10 + audioData.bass * 15;\n    const vx = Math.cos(angle) * force;\n    const vy = Math.sin(angle) * force;\n    \n    // Bright, saturated colors for beat effects\n    const hue = Math.random();\n    const color = [\n      0.8 + Math.random() * 0.2,  // High red/magenta\n      hue < 0.5 ? hue * 2 : 0,    // Variable green\n      hue > 0.5 ? (hue - 0.5) * 2 : 1  // Variable blue\n    ];\n    \n    fluidInstance.splat(x, y, vx, vy, color);\n  }\n}\n\n// AUDIO-REACTIVE SPLAT GENERATOR\n// Maps audio frequency data to physics parameters\nexport function generateAudioReactiveSplat(\n  fluidInstance: any,\n  canvas: HTMLCanvasElement,\n  audioData: {\n    bass: number;\n    mids: number;\n    treble: number;\n    volume: number;\n    spectralData?: Float32Array;\n  },\n  physicsParams: AudioReactiveParams\n): void {\n  if (!fluidInstance || !fluidInstance.splat || !canvas) return;\n  \n  // Position influenced by mid frequencies (creates movement patterns)\n  const x = canvas.width * (0.3 + audioData.mids * 0.4);\n  const y = canvas.height * (0.3 + audioData.treble * 0.4);\n  \n  // Velocity based on bass and overall audio energy\n  const vx = (audioData.bass - 0.5) * physicsParams.splatForce;\n  const vy = (audioData.volume - 0.5) * physicsParams.splatForce;\n  \n  // Color influenced by treble (affects the color phase)\n  const phase = physicsParams.colorPhase;\n  const color = [\n    0.5 + Math.cos(phase) * 0.5,\n    0.5 + Math.cos(phase + Math.PI * 2 / 3) * 0.5,\n    0.5 + Math.cos(phase + Math.PI * 4 / 3) * 0.5\n  ];\n  \n  // Apply global intensity\n  const intensity = physicsParams.globalIntensity;\n  color[0] *= intensity;\n  color[1] *= intensity;\n  color[2] *= intensity;\n  \n  fluidInstance.splat(x, y, vx, vy, color);\n}\n\n// MOUSE/TOUCH INTERACTION HANDLER\n// Handles user interaction while maintaining pointer-events: none on canvas\nexport function setupInteractionHandler(\n  fluidInstance: any,\n  canvas: HTMLCanvasElement\n): () => void {\n  let lastMouseX = 0;\n  let lastMouseY = 0;\n  let isMouseDown = false;\n  \n  const handlePointerMove = (event: PointerEvent) => {\n    if (!fluidInstance || !fluidInstance.splat) return;\n    \n    const rect = canvas.getBoundingClientRect();\n    const x = ((event.clientX - rect.left) / rect.width) * canvas.width;\n    const y = ((event.clientY - rect.top) / rect.height) * canvas.height;\n    \n    if (isMouseDown && (lastMouseX !== 0 || lastMouseY !== 0)) {\n      const vx = (x - lastMouseX) * 0.5;\n      const vy = (y - lastMouseY) * 0.5;\n      \n      // Interactive splats use bright, attention-grabbing colors\n      const color = [1, 0.9, 0.3]; // Bright yellow-orange\n      \n      fluidInstance.splat(x, y, vx, vy, color);\n    }\n    \n    lastMouseX = x;\n    lastMouseY = y;\n  };\n  \n  const handlePointerDown = (event: PointerEvent) => {\n    isMouseDown = true;\n    handlePointerMove(event); // Immediate splat on click\n  };\n  \n  const handlePointerUp = () => {\n    isMouseDown = false;\n  };\n  \n  // Use document listeners since canvas has pointer-events: none\n  document.addEventListener('pointermove', handlePointerMove);\n  document.addEventListener('pointerdown', handlePointerDown);\n  document.addEventListener('pointerup', handlePointerUp);\n  \n  // Cleanup function\n  return () => {\n    document.removeEventListener('pointermove', handlePointerMove);\n    document.removeEventListener('pointerdown', handlePointerDown);\n    document.removeEventListener('pointerup', handlePointerUp);\n  };\n}\n"